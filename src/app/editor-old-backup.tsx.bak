"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { useLocalStorage } from "usehooks-ts";
import { toast, Toaster } from "sonner";
import {
  NoteEditor,
  EditorNote,
  NoteTool,
  RepeatMarker,
  TimeSignature,
  LEFT_MARGIN,
  BEAT_WIDTH,
  getLayoutConfig,
  getBeatFromX,
} from "@/components/NoteEditor";
import { PianoDrawer } from "@/components/PianoDrawer";
import { EditorHeader } from "@/components/EditorHeader";
import { ToolPalette } from "@/components/ToolPalette";
import { SettingsModal } from "@/components/SettingsModal";
import { SongLibraryModal } from "@/components/SongLibraryModal";
import { HelpModal } from "@/components/HelpModal";
import { getAudioPlayer } from "@/lib/audio/AudioPlayer";
import { MIDI_NOTES } from "@/lib/constants";
import { Pitch, SavedSong, SavedSongsMap } from "@/lib/types";
import { getDefaultSongs } from "@/lib/defaultSongs";

// Playback types
interface PlaybackNote extends EditorNote {
  playBeat: number;
}

interface TimelineSegment {
  startBeat: number;
  endBeat: number;
  system: number;
  startX: number;
  endX: number;
}

// Types for localStorage persistence
interface EditorComposition {
  notes: EditorNote[];
  repeatMarkers: RepeatMarker[];
  systemCount: number;
}

interface EditorSettings {
  selectedTool: NoteTool;
  showLabels: boolean;
  showKidFaces: boolean;
  showGrid: boolean;
  allowChords: boolean;
  tempo: number;
  timeSignature: TimeSignature;
  pianoUseColors: boolean;
  pianoShowBlackKeys: boolean;
}

interface EditorUI {
  showPiano: boolean;
  showSongLibrary: boolean;
  showSettings: boolean;
  showHelp: boolean;
}

const DEFAULT_COMPOSITION: EditorComposition = {
  notes: [],
  repeatMarkers: [],
  systemCount: 1,
};

const DEFAULT_SETTINGS: EditorSettings = {
  selectedTool: "quarter",
  showLabels: true,
  showKidFaces: false,
  showGrid: false,
  allowChords: false,
  tempo: 100,
  timeSignature: { numerator: 4, denominator: 4 },
  pianoUseColors: true,
  pianoShowBlackKeys: false,
};

const DEFAULT_UI: EditorUI = {
  showPiano: false,
  showSongLibrary: false,
  showSettings: false,
  showHelp: false,
};

export default function EditorPage() {
  // Persistent state
  const [composition, setComposition] = useLocalStorage<EditorComposition>(
    "rochel-editor-composition",
    DEFAULT_COMPOSITION,
  );
  const [settings, setSettings] = useLocalStorage<EditorSettings>(
    "rochel-editor-settings",
    DEFAULT_SETTINGS,
  );
  const [ui, setUI] = useLocalStorage<EditorUI>("rochel-editor-ui", DEFAULT_UI);
  const [savedSongs, setSavedSongs] = useLocalStorage<SavedSongsMap>(
    "rochel-saved-songs",
    getDefaultSongs(),
  );
  const [currentSongId, setCurrentSongId] = useLocalStorage<string | null>(
    "rochel-current-song-id",
    null,
  );

  // Playback state
  const [isPlaying, setIsPlaying] = useState(false);
  const [playheadX, setPlayheadX] = useState<number | null>(null);
  const [playheadSystem, setPlayheadSystem] = useState<number>(0);
  const [activePitch, setActivePitch] = useState<Pitch | null>(null);
  const [activeNoteId, setActiveNoteId] = useState<string | null>(null);
  const [activeNoteDuration, setActiveNoteDuration] = useState<
    number | undefined
  >();
  const [activeNoteStartTime, setActiveNoteStartTime] = useState<
    number | undefined
  >();

  // Refs for playback
  const playbackStartTimeRef = useRef<number>(0);
  const playbackAnimationRef = useRef<number>(0);
  const playedNotesRef = useRef<Set<string>>(new Set());

  // Undo/Redo state
  const [history, setHistory] = useState<EditorComposition[]>([composition]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // Current song title
  const currentSongTitle =
    currentSongId && savedSongs[currentSongId]
      ? savedSongs[currentSongId].name
      : "Untitled Song";

  // Update composition helper
  const updateComposition = useCallback(
    (updates: Partial<EditorComposition>) => {
      const newComposition = { ...composition, ...updates };
      setComposition(newComposition);

      // Add to history for undo/redo
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(newComposition);
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
    },
    [composition, history, historyIndex, setComposition],
  );

  // Undo/Redo handlers
  const handleUndo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setComposition(history[newIndex]);
    }
  }, [historyIndex, history, setComposition]);

  const handleRedo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setComposition(history[newIndex]);
    }
  }, [historyIndex, history, setComposition]);

  // Keyboard shortcuts for undo/redo
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "z" && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if (
        (e.metaKey || e.ctrlKey) &&
        (e.key === "Z" || (e.key === "z" && e.shiftKey))
      ) {
        e.preventDefault();
        handleRedo();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleUndo, handleRedo]);

  // Stop playback handler
  const stopPlayback = useCallback(() => {
    const player = getAudioPlayer();
    player.stop();
    setIsPlaying(false);
    setPlayheadX(null);
    setPlayheadSystem(0);
    setActivePitch(null);
    setActiveNoteId(null);
    if (playbackAnimationRef.current) {
      cancelAnimationFrame(playbackAnimationRef.current);
    }
  }, []);

  // Play handler (simplified - will expand with full playback logic)
  const handlePlay = useCallback(() => {
    if (isPlaying) {
      stopPlayback();
      return;
    }

    if (composition.notes.length === 0) {
      toast.error("No notes to play");
      return;
    }

    // TODO: Implement full playback logic from old editor
    setIsPlaying(true);
    toast.success("Playback started");
  }, [isPlaying, composition.notes, stopPlayback]);

  // Tool selection
  const handleToolSelect = useCallback(
    (tool: NoteTool) => {
      setSettings({ ...settings, selectedTool: tool });
    },
    [settings, setSettings],
  );

  // Save current composition as song
  const handleSaveSong = useCallback(
    (name: string) => {
      const songId = currentSongId || `song_${Date.now()}`;
      const song: SavedSong = {
        id: songId,
        name,
        composition: {
          notes: composition.notes,
          repeatMarkers: composition.repeatMarkers,
          systemCount: composition.systemCount,
        },
        settings: {
          tempo: settings.tempo,
          timeSignature: settings.timeSignature,
        },
        createdAt: savedSongs[songId]?.createdAt || Date.now(),
        updatedAt: Date.now(),
      };

      setSavedSongs({ ...savedSongs, [songId]: song });
      setCurrentSongId(songId);
      toast.success(`Saved "${name}"`);
    },
    [
      currentSongId,
      composition,
      settings,
      savedSongs,
      setSavedSongs,
      setCurrentSongId,
    ],
  );

  // Additional handlers for new components
  const handleLoadSong = useCallback(
    (song: SavedSong) => {
      setComposition({
        notes: song.composition.notes,
        repeatMarkers: song.composition.repeatMarkers,
        systemCount: song.composition.systemCount,
      });
      setSettings({
        ...settings,
        tempo: song.settings.tempo,
        timeSignature: song.settings.timeSignature,
      });
      setCurrentSongId(song.id);
      setUI({ ...ui, showSongLibrary: false });
      toast.success(`Loaded "${song.name}"`);
    },
    [settings, ui, setComposition, setSettings, setCurrentSongId, setUI],
  );

  const handleDeleteSong = useCallback(
    (songId: string) => {
      const newSongs = { ...savedSongs };
      delete newSongs[songId];
      setSavedSongs(newSongs);
      if (currentSongId === songId) {
        setCurrentSongId(null);
      }
      toast.success("Song deleted");
    },
    [savedSongs, currentSongId, setSavedSongs, setCurrentSongId],
  );

  const handleRestoreDefaults = useCallback(() => {
    setSavedSongs(getDefaultSongs());
    toast.success("Default songs restored");
  }, [setSavedSongs]);

  const handleExport = useCallback(() => {
    const dataStr = JSON.stringify(savedSongs, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "rochel-songs.json";
    link.click();
    URL.revokeObjectURL(url);
    toast.success("Songs exported");
  }, [savedSongs]);

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      <Toaster position="top-center" />

      {/* Header */}
      <EditorHeader
        currentSongTitle={currentSongTitle}
        onSongTitleClick={() => setUI({ ...ui, showSongLibrary: true })}
        tempo={settings.tempo}
        onTempoChange={(tempo) => setSettings({ ...settings, tempo })}
        timeSignature={settings.timeSignature}
        onSave={() => {
          const name = prompt("Enter song name:");
          if (name) handleSaveSong(name);
        }}
        onSettings={() => setUI({ ...ui, showSettings: true })}
        onHelp={() => setUI({ ...ui, showHelp: true })}
        onPlay={handlePlay}
        isPlaying={isPlaying}
        hasNotes={composition.notes.length > 0}
        showPiano={ui.showPiano}
        onTogglePiano={() => setUI({ ...ui, showPiano: !ui.showPiano })}
        canUndo={historyIndex > 0}
        canRedo={historyIndex < history.length - 1}
        onUndo={handleUndo}
        onRedo={handleRedo}
        onDownloadPNG={() =>
          console.log("Download PNG - not implemented in backup")
        }
        onDownloadSVG={() =>
          console.log("Download SVG - not implemented in backup")
        }
      />

      {/* Main content area */}
      <div className="flex-1 flex relative overflow-hidden">
        {/* Canvas area */}
        <div className="flex-1 flex flex-col overflow-auto">
          <NoteEditor
            notes={composition.notes}
            onNotesChange={(notes) => updateComposition({ notes })}
            repeatMarkers={composition.repeatMarkers}
            onRepeatMarkersChange={(markers) =>
              updateComposition({ repeatMarkers: markers })
            }
            selectedTool={settings.selectedTool}
            showLabels={settings.showLabels}
            showKidFaces={settings.showKidFaces}
            showGrid={settings.showGrid}
            allowChords={settings.allowChords}
            timeSignature={settings.timeSignature}
            systemCount={composition.systemCount}
            onSystemCountChange={(count) =>
              updateComposition({ systemCount: count })
            }
            tempo={settings.tempo}
            isPlaying={isPlaying}
            playheadX={playheadX}
            playheadSystem={playheadSystem}
            activeNoteId={activeNoteId}
          />
        </div>

        {/* Tool Palette */}
        <ToolPalette
          selectedTool={settings.selectedTool}
          onToolSelect={(tool) =>
            setSettings({ ...settings, selectedTool: tool })
          }
        />
      </div>

      {/* Piano drawer */}
      {ui.showPiano && (
        <PianoDrawer
          activePitch={activePitch}
          activeNoteDuration={activeNoteDuration}
          activeNoteStartTime={activeNoteStartTime}
          tempo={settings.tempo}
          useColors={settings.pianoUseColors}
          onToggleColors={() =>
            setSettings({
              ...settings,
              pianoUseColors: !settings.pianoUseColors,
            })
          }
          showBlackKeys={settings.pianoShowBlackKeys}
          onToggleBlackKeys={() =>
            setSettings({
              ...settings,
              pianoShowBlackKeys: !settings.pianoShowBlackKeys,
            })
          }
        />
      )}

      {/* Modals */}
      <SongLibraryModal
        isOpen={ui.showSongLibrary}
        onClose={() => setUI({ ...ui, showSongLibrary: false })}
        savedSongs={savedSongs}
        currentSongId={currentSongId}
        onLoadSong={handleLoadSong}
        onDeleteSong={handleDeleteSong}
        onSaveSong={handleSaveSong}
        onRestoreDefaults={handleRestoreDefaults}
        onExport={handleExport}
      />

      <SettingsModal
        isOpen={ui.showSettings}
        onClose={() => setUI({ ...ui, showSettings: false })}
        tempo={settings.tempo}
        onTempoChange={(tempo) => setSettings({ ...settings, tempo })}
        timeSignature={settings.timeSignature}
        onTimeSignatureChange={(ts) =>
          setSettings({ ...settings, timeSignature: ts })
        }
        showLabels={settings.showLabels}
        onShowLabelsChange={(show) =>
          setSettings({ ...settings, showLabels: show })
        }
        showKidFaces={settings.showKidFaces}
        onShowKidFacesChange={(show) =>
          setSettings({ ...settings, showKidFaces: show })
        }
        showGrid={settings.showGrid}
        onShowGridChange={(show) =>
          setSettings({ ...settings, showGrid: show })
        }
        allowChords={settings.allowChords}
        onAllowChordsChange={(allow) =>
          setSettings({ ...settings, allowChords: allow })
        }
      />

      <HelpModal
        isOpen={ui.showHelp}
        onClose={() => setUI({ ...ui, showHelp: false })}
      />
    </div>
  );
}
