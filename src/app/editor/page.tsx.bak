"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { useLocalStorage } from "usehooks-ts";
import { toast, Toaster } from "sonner";
import {
  NoteEditor,
  NoteTool,
  TimeSignature,
  LEFT_MARGIN,
  BEAT_WIDTH,
  getLayoutConfig,
  getBeatFromX,
} from "@/components/NoteEditor";
import { PianoDrawer } from "@/components/PianoDrawer";
import { EditorHeader } from "@/components/EditorHeader";
import { ToolPalette } from "@/components/ToolPalette";
import { SettingsModal } from "@/components/SettingsModal";
import { SongLibraryModal } from "@/components/SongLibraryModal";
import { HelpModal } from "@/components/HelpModal";
import { getAudioPlayer } from "@/lib/audio/AudioPlayer";
import { MIDI_NOTES } from "@/lib/constants";
import {
  Pitch,
  SavedSong,
  SavedSongsMap,
  Composition,
  LegacyComposition,
  EditorNote,
  RepeatMarker,
} from "@/lib/types";
import { getDefaultSongs } from "@/lib/defaultSongs";
import {
  migrateSavedSong,
  migrateAllSongs,
  isLegacyComposition,
  getAbsoluteBeat,
  calculateSystemCount,
  getAbsoluteMeasureNumber,
  getBeatsPerSystem,
} from "@/lib/migration";
import { useResponsiveLayout } from "@/hooks/useResponsiveLayout";
import { usePlayback } from "@/hooks/usePlayback";
import {
  toLegacyNotes,
  fromLegacyNotes,
  toLegacyRepeatMarkers,
  fromLegacyRepeatMarkers,
  calculateLegacySystemCount,
} from "@/lib/coordinateAdapter";

// Playback types
interface PlaybackNote extends EditorNote {
  playBeat: number;
}

interface TimelineSegment {
  startBeat: number;
  endBeat: number;
  system: number;
  startX: number;
  endX: number;
}

// Types for localStorage persistence
// Supports both legacy (system-based) and new (absoluteBeat) formats during migration
type EditorComposition = Composition | LegacyComposition;

interface EditorSettings {
  selectedTool: NoteTool;
  showLabels: boolean;
  showKidFaces: boolean;
  showGrid: boolean;
  allowChords: boolean;
  tempo: number;
  timeSignature: TimeSignature;
  pianoUseColors: boolean;
  pianoShowBlackKeys: boolean;
}

interface EditorUI {
  showPiano: boolean;
  showSongLibrary: boolean;
  showSettings: boolean;
  showHelp: boolean;
}

const DEFAULT_COMPOSITION: Composition = {
  notes: [],
  repeatMarkers: [],
};

const DEFAULT_SETTINGS: EditorSettings = {
  selectedTool: "quarter",
  showLabels: true,
  showKidFaces: false,
  showGrid: false,
  allowChords: false,
  tempo: 100,
  timeSignature: { numerator: 4, denominator: 4 },
  pianoUseColors: true,
  pianoShowBlackKeys: false,
};

const DEFAULT_UI: EditorUI = {
  showPiano: false,
  showSongLibrary: false,
  showSettings: false,
  showHelp: false,
};

export default function EditorPage() {
  // Persistent state
  const [composition, setComposition] = useLocalStorage<EditorComposition>(
    "rochel-editor-composition",
    DEFAULT_COMPOSITION,
  );
  const [settings, setSettings] = useLocalStorage<EditorSettings>(
    "rochel-editor-settings",
    DEFAULT_SETTINGS,
  );
  const [ui, setUI] = useLocalStorage<EditorUI>("rochel-editor-ui", DEFAULT_UI);
  const [savedSongs, setSavedSongs] = useLocalStorage<SavedSongsMap>(
    "rochel-saved-songs",
    getDefaultSongs(),
  );
  const [currentSongId, setCurrentSongId] = useLocalStorage<string | null>(
    "rochel-current-song-id",
    null,
  );
  const [measuresPerRow, setMeasuresPerRow] = useLocalStorage<number>(
    "rochel-measures-per-row",
    2, // Default: 2 measures per row
  );

  // SVG ref for export functionality
  const svgRef = useRef<SVGSVGElement>(null);

  // Ref for responsive layout
  const editorContainerRef = useRef<HTMLDivElement>(null);

  // Calculate total beats for layout
  const beatsPerSystem = getBeatsPerSystem(settings.timeSignature);
  const systemCount = calculateSystemCount(composition, beatsPerSystem);
  const totalBeats = systemCount * beatsPerSystem;

  // Get responsive layout configuration
  const layout = useResponsiveLayout(editorContainerRef, {
    timeSignature: settings.timeSignature,
    totalBeats,
    userMeasuresPerRow: measuresPerRow,
  });

  // Playback hook
  const playback = usePlayback({
    composition: composition as Composition,
    tempo: settings.tempo,
    timeSignature: settings.timeSignature,
  });

  // Undo/Redo state
  const [history, setHistory] = useState<EditorComposition[]>([composition]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // Current song title
  const currentSongTitle =
    currentSongId && savedSongs[currentSongId]
      ? savedSongs[currentSongId].name
      : "Untitled Song";

  // Update composition helper with history tracking
  const updateComposition = useCallback(
    (updates: Partial<EditorComposition>) => {
      const newComposition = {
        ...composition,
        ...updates,
      } as EditorComposition;
      setComposition(newComposition);

      // Add to history for undo/redo
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(newComposition);
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
    },
    [composition, history, historyIndex, setComposition],
  );

  // Undo/Redo handlers
  const handleUndo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setComposition(history[newIndex]);
    }
  }, [historyIndex, history, setComposition]);

  const handleRedo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setComposition(history[newIndex]);
    }
  }, [historyIndex, history, setComposition]);

  // Auto-migrate saved songs on mount (runs once)
  useEffect(() => {
    let needsMigration = false;

    // Check if any songs need migration
    for (const song of Object.values(savedSongs)) {
      if (isLegacyComposition(song.composition)) {
        needsMigration = true;
        break;
      }
    }

    // Perform migration if needed
    if (needsMigration) {
      console.log("Migrating saved songs to new format...");
      const migratedSongs = migrateAllSongs(savedSongs);
      setSavedSongs(migratedSongs);
      toast.success("Songs updated to new format");
    }

    // Also migrate current composition if needed
    if (isLegacyComposition(composition)) {
      console.log("Migrating current composition to new format...");
      const migratedComp = migrateSavedSong({
        id: "temp",
        name: "temp",
        composition,
        settings: settings,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }).composition;
      setComposition(migratedComp);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount

  // Keyboard shortcuts for undo/redo
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "z" && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if (
        (e.metaKey || e.ctrlKey) &&
        (e.key === "Z" || (e.key === "z" && e.shiftKey))
      ) {
        e.preventDefault();
        handleRedo();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleUndo, handleRedo]);

  // Playback handlers are now in the usePlayback hook



    // Get layout config
    const layout = getLayoutConfig(settings.timeSignature);
    const BEATS_PER_SYSTEM = layout.beatsPerSystem;
    const beatsPerMeasure = layout.beatsPerMeasure;

    setIsPlaying(true);
    isPlayingRef.current = true;
    const player = getAudioPlayer();
    player.setTempo(settings.tempo);

    // Calculate timing
    const msPerBeat = 60000 / settings.tempo;
    const beatsPerSystem = getBeatsPerSystem(settings.timeSignature);
    const systemCount = calculateSystemCount(composition, beatsPerSystem);
    const totalBeats = systemCount * beatsPerSystem;

    // Sort notes by position for playback (works with both formats)
    const sortedNotes = [...composition.notes].sort((a, b) => {
      const beatA = getAbsoluteBeat(a, beatsPerSystem);
      const beatB = getAbsoluteBeat(b, beatsPerSystem);
      return beatA - beatB;
    });

    // Build repeat sections from paired markers
    interface RepeatSection {
      pairId: string;
      startSystem: number;
      startMeasure: number;
      endSystem: number;
      endMeasure: number;
      startAbsoluteBeat: number;
      endAbsoluteBeat: number;
    }
    const repeatSections: RepeatSection[] = [];
    const processedPairIds = new Set<string>();

    const measuresPerSystem = 2; // TODO: Make configurable in Phase 2
    for (const marker of composition.repeatMarkers) {
      if (marker.type !== "start" || processedPairIds.has(marker.pairId))
        continue;
      const endMarker = composition.repeatMarkers.find(
        (m) => m.pairId === marker.pairId && m.type === "end",
      );
      if (endMarker) {
        const startMeasureNum = getAbsoluteMeasureNumber(
          marker,
          measuresPerSystem,
        );
        const endMeasureNum = getAbsoluteMeasureNumber(
          endMarker,
          measuresPerSystem,
        );
        const startAbsoluteBeat = startMeasureNum * beatsPerMeasure;
        const endAbsoluteBeat = endMeasureNum * beatsPerMeasure;

        if (endAbsoluteBeat > startAbsoluteBeat) {
          // Calculate legacy format for backward compatibility
          const startSystem = Math.floor(startMeasureNum / measuresPerSystem);
          const startMeasure = startMeasureNum % measuresPerSystem;
          const endSystem = Math.floor(endMeasureNum / measuresPerSystem);
          const endMeasure = endMeasureNum % measuresPerSystem;

          repeatSections.push({
            pairId: marker.pairId,
            startSystem,
            startMeasure,
            endSystem,
            endMeasure,
            startAbsoluteBeat,
            endAbsoluteBeat,
          });
        }
        processedPairIds.add(marker.pairId);
      }
    }
    repeatSections.sort((a, b) => a.startAbsoluteBeat - b.startAbsoluteBeat);

    // Build playback sequence with repeat handling
    const playbackSequence: PlaybackNote[] = [];

    // Helper to get absolute beat for a note (works with both formats)
    const getNoteAbsoluteBeat = (note: any) =>
      getAbsoluteBeat(note, beatsPerSystem);

    // Build timeline with repeats
    let currentBeatOffset = 0;
    let lastProcessedBeat = 0;

    for (const section of repeatSections) {
      // Add notes before this repeat section
      for (const note of sortedNotes) {
        const noteBeat = getNoteAbsoluteBeat(note);
        if (
          noteBeat >= lastProcessedBeat &&
          noteBeat < section.startAbsoluteBeat
        ) {
          playbackSequence.push({
            ...note,
            playBeat: currentBeatOffset + (noteBeat - lastProcessedBeat),
          } as PlaybackNote);
        }
      }
      currentBeatOffset += section.startAbsoluteBeat - lastProcessedBeat;

      // First pass of repeated section
      for (const note of sortedNotes) {
        const noteBeat = getNoteAbsoluteBeat(note);
        if (
          noteBeat >= section.startAbsoluteBeat &&
          noteBeat < section.endAbsoluteBeat
        ) {
          playbackSequence.push({
            ...note,
            playBeat:
              currentBeatOffset + (noteBeat - section.startAbsoluteBeat),
          } as PlaybackNote);
        }
      }
      currentBeatOffset += section.endAbsoluteBeat - section.startAbsoluteBeat;

      // Second pass of repeated section
      for (const note of sortedNotes) {
        const noteBeat = getNoteAbsoluteBeat(note);
        if (
          noteBeat >= section.startAbsoluteBeat &&
          noteBeat < section.endAbsoluteBeat
        ) {
          playbackSequence.push({
            ...note,
            playBeat:
              currentBeatOffset + (noteBeat - section.startAbsoluteBeat),
          } as PlaybackNote);
        }
      }
      currentBeatOffset += section.endAbsoluteBeat - section.startAbsoluteBeat;

      lastProcessedBeat = section.endAbsoluteBeat;
    }

    // Add notes after all repeat sections
    for (const note of sortedNotes) {
      const noteBeat = getNoteAbsoluteBeat(note);
      if (noteBeat >= lastProcessedBeat) {
        playbackSequence.push({
          ...note,
          playBeat: currentBeatOffset + (noteBeat - lastProcessedBeat),
        } as PlaybackNote);
      }
    }
    currentBeatOffset += totalBeats - lastProcessedBeat;

    // Sort by play time
    playbackSequence.sort((a, b) => a.playBeat - b.playBeat);

    // Build visual timeline segments for playhead
    const timeline: TimelineSegment[] = [];

    // Helper to convert absolute beat to system + X position
    const absoluteBeatToVisual = (absBeat: number) => {
      const system = Math.floor(absBeat / BEATS_PER_SYSTEM);
      const beatInSystem = absBeat % BEATS_PER_SYSTEM;
      return {
        system,
        x: LEFT_MARGIN + beatInSystem * BEAT_WIDTH,
      };
    };

    // Helper to add timeline segments between two absolute beats
    const addSegmentsBetween = (
      startAbsBeat: number,
      endAbsBeat: number,
      timelineStart: number,
    ) => {
      let currentBeat = startAbsBeat;
      let currentTimelineBeat = timelineStart;

      while (currentBeat < endAbsBeat) {
        const startVisual = absoluteBeatToVisual(currentBeat);
        const systemEndBeat = (startVisual.system + 1) * BEATS_PER_SYSTEM;
        const segmentEndBeat = Math.min(endAbsBeat, systemEndBeat);
        const endVisual = absoluteBeatToVisual(segmentEndBeat);

        const duration = segmentEndBeat - currentBeat;
        timeline.push({
          startBeat: currentTimelineBeat,
          endBeat: currentTimelineBeat + duration,
          system: startVisual.system,
          startX: startVisual.x,
          endX:
            segmentEndBeat === systemEndBeat
              ? LEFT_MARGIN + BEATS_PER_SYSTEM * BEAT_WIDTH
              : endVisual.x,
        });

        currentTimelineBeat += duration;
        currentBeat = segmentEndBeat;
      }
      return currentTimelineBeat;
    };

    let timelineBeat = 0;
    let lastProcessedAbsBeat = 0;

    for (const section of repeatSections) {
      // Add segments before this repeat
      if (section.startAbsoluteBeat > lastProcessedAbsBeat) {
        timelineBeat = addSegmentsBetween(
          lastProcessedAbsBeat,
          section.startAbsoluteBeat,
          timelineBeat,
        );
      }

      // First pass of repeat
      timelineBeat = addSegmentsBetween(
        section.startAbsoluteBeat,
        section.endAbsoluteBeat,
        timelineBeat,
      );

      // Second pass of repeat (visual loop back)
      timelineBeat = addSegmentsBetween(
        section.startAbsoluteBeat,
        section.endAbsoluteBeat,
        timelineBeat,
      );

      lastProcessedAbsBeat = section.endAbsoluteBeat;
    }

    // Add segments after all repeats
    if (lastProcessedAbsBeat < totalBeats) {
      timelineBeat = addSegmentsBetween(
        lastProcessedAbsBeat,
        totalBeats,
        timelineBeat,
      );
    }

    const totalPlaybackBeats = timelineBeat || currentBeatOffset;
    const totalPlaybackMs = totalPlaybackBeats * msPerBeat;

    // Track state during animation
    const playedNotes = new Set<number>();
    const activeNotes = new Map<string, number>();
    const startTime = performance.now();

    // Store in refs
    playbackSequenceRef.current = playbackSequence;
    timelineRef.current = timeline;
    msPerBeatRef.current = msPerBeat;
    playbackStartTimeRef.current = startTime;
    playedNotesRef.current = playedNotes;

    const animate = () => {
      if (!isPlayingRef.current) {
        setPlayheadX(null);
        setActiveNoteId(null);
        setActivePitch(null);
        setIsPlaying(false);
        return;
      }

      const elapsed = performance.now() - playbackStartTimeRef.current;
      const currentBeat = elapsed / msPerBeatRef.current;

      // Find current timeline segment and interpolate position
      let currentSystem = 0;
      let currentX = LEFT_MARGIN;

      for (const segment of timeline) {
        if (currentBeat >= segment.startBeat && currentBeat < segment.endBeat) {
          const progress =
            (currentBeat - segment.startBeat) /
            (segment.endBeat - segment.startBeat);
          currentSystem = segment.system;
          currentX =
            segment.startX + progress * (segment.endX - segment.startX);
          break;
        } else if (currentBeat >= segment.endBeat) {
          currentSystem = segment.system;
          currentX = segment.endX;
        }
      }

      setPlayheadX(currentX);
      setPlayheadSystem(currentSystem);

      // Check for notes to play
      for (let i = 0; i < playbackSequence.length; i++) {
        if (playedNotesRef.current.has(i)) continue;
        const note = playbackSequence[i];
        if (currentBeat >= note.playBeat) {
          // Play this note
          const midi = MIDI_NOTES[note.pitch];
          if (midi > 0) {
            const durationSeconds = (note.duration * 60) / settings.tempo;
            player.playNote(midi, durationSeconds * 0.9);
          }
          playedNotesRef.current.add(i);

          // Set as active note
          const noteEndTime = elapsed + note.duration * msPerBeatRef.current;
          activeNotes.set(note.id, noteEndTime);
          setActiveNoteId(note.id);
          setActivePitch(note.pitch);
          setActiveNoteDuration(note.duration);
          setActiveNoteStartTime(performance.now());
        }
      }

      // Clear expired active notes
      for (const [noteId, endTime] of activeNotes) {
        if (elapsed >= endTime) {
          activeNotes.delete(noteId);
          if (activeNotes.size === 0) {
            setActiveNoteId(null);
            setActivePitch(null);
          }
        }
      }

      // Continue or stop
      if (elapsed < totalPlaybackMs) {
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setPlayheadX(null);
        setActiveNoteId(null);
        setActivePitch(null);
        setIsPlaying(false);
        isPlayingRef.current = false;
      }
    };

    animationRef.current = requestAnimationFrame(animate);
  }, [
    composition.notes,
    composition.repeatMarkers,
    settings.tempo,
    settings.timeSignature,
    stopPlayback,
  ]);

  // Save current composition as song
  const handleSaveSong = useCallback(
    (name: string) => {
      const songId = currentSongId || `song_${Date.now()}`;

      // Ensure composition is migrated before saving
      const migratedComp = isLegacyComposition(composition)
        ? migrateSavedSong({
            id: songId,
            name,
            composition,
            settings,
            createdAt: Date.now(),
            updatedAt: Date.now(),
          }).composition
        : composition;
      const migratedComposition = migratedComp as Composition;

      const song: SavedSong = {
        id: songId,
        name,
        composition: migratedComposition,
        settings: {
          tempo: settings.tempo,
          timeSignature: settings.timeSignature,
        },
        createdAt: savedSongs[songId]?.createdAt || Date.now(),
        updatedAt: Date.now(),
      };

      setSavedSongs({ ...savedSongs, [songId]: song });
      setCurrentSongId(songId);
      toast.success(`Saved "${name}"`);
    },
    [
      currentSongId,
      composition,
      settings,
      savedSongs,
      setSavedSongs,
      setCurrentSongId,
    ],
  );

  // Load song handler (with automatic migration)
  const handleLoadSong = useCallback(
    (song: SavedSong) => {
      // Migrate if needed
      const migratedSong = migrateSavedSong(song);

      setComposition(migratedSong.composition);
      setSettings({
        ...settings,
        tempo: migratedSong.settings.tempo,
        timeSignature: migratedSong.settings.timeSignature,
      });
      setCurrentSongId(migratedSong.id);
      setUI({ ...ui, showSongLibrary: false });
      toast.success(`Loaded "${migratedSong.name}"`);

      // Save migrated version if it was updated
      if (migratedSong.updatedAt !== song.updatedAt) {
        setSavedSongs({ ...savedSongs, [migratedSong.id]: migratedSong });
      }
    },
    [
      settings,
      ui,
      savedSongs,
      setComposition,
      setSettings,
      setCurrentSongId,
      setUI,
      setSavedSongs,
    ],
  );

  // Delete song handler
  const handleDeleteSong = useCallback(
    (songId: string) => {
      const newSongs = { ...savedSongs };
      delete newSongs[songId];
      setSavedSongs(newSongs);
      if (currentSongId === songId) {
        setCurrentSongId(null);
      }
      toast.success("Song deleted");
    },
    [savedSongs, currentSongId, setSavedSongs, setCurrentSongId],
  );

  // Restore defaults handler
  const handleRestoreDefaults = useCallback(() => {
    setSavedSongs(getDefaultSongs());
    toast.success("Default songs restored");
  }, [setSavedSongs]);

  // Export handler
  const handleExport = useCallback(() => {
    const dataStr = JSON.stringify(savedSongs, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "rochel-songs.json";
    link.click();
    URL.revokeObjectURL(url);
    toast.success("Songs exported");
  }, [savedSongs]);

  // Save as PNG
  const handleSavePNG = useCallback(() => {
    if (!svgRef.current) return;

    const svg = svgRef.current;
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const svgData = new XMLSerializer().serializeToString(svg);
    const svgBlob = new Blob([svgData], {
      type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    img.onload = () => {
      canvas.width = svg.clientWidth * 2;
      canvas.height = svg.clientHeight * 2;
      ctx.scale(2, 2);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      URL.revokeObjectURL(url);

      const link = document.createElement("a");
      link.download = "music-composition.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
      toast.success("Exported as PNG");
    };
    img.src = url;
  }, []);

  // Save as SVG
  const handleSaveSVG = useCallback(() => {
    if (!svgRef.current) return;

    const svg = svgRef.current;
    const svgData = new XMLSerializer().serializeToString(svg);
    const svgBlob = new Blob([svgData], {
      type: "image/svg+xml;charset=utf-8",
    });
    const url = URL.createObjectURL(svgBlob);

    const link = document.createElement("a");
    link.download = "music-composition.svg";
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
    toast.success("Exported as SVG");
  }, []);

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      <Toaster position="top-center" />

      {/* Header */}
      <EditorHeader
        currentSongTitle={currentSongTitle}
        onSongTitleClick={() => setUI({ ...ui, showSongLibrary: true })}
        tempo={settings.tempo}
        onTempoChange={(tempo) => setSettings({ ...settings, tempo })}
        timeSignature={settings.timeSignature}
        measuresPerRow={measuresPerRow}
        onMeasuresPerRowChange={setMeasuresPerRow}
        containerWidth={layout.containerWidth}
        onSave={() => {
          const name = prompt("Enter song name:");
          if (name) handleSaveSong(name);
        }}
        onSettings={() => setUI({ ...ui, showSettings: true })}
        onHelp={() => setUI({ ...ui, showHelp: true })}
        onPlay={handlePlay}
        isPlaying={isPlaying}
        hasNotes={composition.notes.length > 0}
        showPiano={ui.showPiano}
        onTogglePiano={() => setUI({ ...ui, showPiano: !ui.showPiano })}
        canUndo={historyIndex > 0}
        canRedo={historyIndex < history.length - 1}
        onUndo={handleUndo}
        onRedo={handleRedo}
        onDownloadPNG={handleSavePNG}
        onDownloadSVG={handleSaveSVG}
      />

      {/* Main content area */}
      <div className="flex-1 flex relative overflow-hidden">
        {/* Canvas area */}
        <div
          ref={editorContainerRef}
          className="flex-1 flex flex-col overflow-auto"
        >
          <NoteEditor
            notes={toLegacyNotes(composition.notes as EditorNote[], layout)}
            onNotesChange={(legacyNotes) => {
              const newNotes = fromLegacyNotes(legacyNotes, layout);
              updateComposition({ notes: newNotes });
            }}
            repeatMarkers={toLegacyRepeatMarkers(
              composition.repeatMarkers as RepeatMarker[],
              layout,
            )}
            onRepeatMarkersChange={(legacyMarkers) => {
              const newMarkers = fromLegacyRepeatMarkers(legacyMarkers, layout);
              updateComposition({ repeatMarkers: newMarkers });
            }}
            selectedTool={settings.selectedTool}
            showLabels={settings.showLabels}
            showKidFaces={settings.showKidFaces}
            showGrid={settings.showGrid}
            allowChords={settings.allowChords}
            timeSignature={settings.timeSignature}
            systemCount={calculateLegacySystemCount(
              composition.notes as EditorNote[],
              layout,
            )}
            onSystemCountChange={(count) => {
              // System count is now calculated dynamically from layout
              // This callback is kept for compatibility but does nothing
              console.log(
                "System count is now dynamic based on layout:",
                count,
              );
            }}
            tempo={settings.tempo}
            isPlaying={isPlaying}
            playheadX={playheadX}
            playheadSystem={playheadSystem}
            activeNoteId={activeNoteId}
            svgRef={svgRef}
          />
        </div>

        {/* Tool Palette */}
        <ToolPalette
          selectedTool={settings.selectedTool}
          onToolSelect={(tool) =>
            setSettings({ ...settings, selectedTool: tool })
          }
        />
      </div>

      {/* Piano drawer */}
      {ui.showPiano && (
        <PianoDrawer
          activePitch={activePitch}
          activeNoteDuration={activeNoteDuration}
          activeNoteStartTime={activeNoteStartTime}
          tempo={settings.tempo}
          useColors={settings.pianoUseColors}
          onToggleColors={() =>
            setSettings({
              ...settings,
              pianoUseColors: !settings.pianoUseColors,
            })
          }
          showBlackKeys={settings.pianoShowBlackKeys}
          onToggleBlackKeys={() =>
            setSettings({
              ...settings,
              pianoShowBlackKeys: !settings.pianoShowBlackKeys,
            })
          }
        />
      )}

      {/* Modals */}
      <SongLibraryModal
        isOpen={ui.showSongLibrary}
        onClose={() => setUI({ ...ui, showSongLibrary: false })}
        savedSongs={savedSongs}
        currentSongId={currentSongId}
        onLoadSong={handleLoadSong}
        onDeleteSong={handleDeleteSong}
        onSaveSong={handleSaveSong}
        onRestoreDefaults={handleRestoreDefaults}
        onExport={handleExport}
      />

      <SettingsModal
        isOpen={ui.showSettings}
        onClose={() => setUI({ ...ui, showSettings: false })}
        tempo={settings.tempo}
        onTempoChange={(tempo) => setSettings({ ...settings, tempo })}
        timeSignature={settings.timeSignature}
        onTimeSignatureChange={(ts) =>
          setSettings({ ...settings, timeSignature: ts })
        }
        showLabels={settings.showLabels}
        onShowLabelsChange={(show) =>
          setSettings({ ...settings, showLabels: show })
        }
        showKidFaces={settings.showKidFaces}
        onShowKidFacesChange={(show) =>
          setSettings({ ...settings, showKidFaces: show })
        }
        showGrid={settings.showGrid}
        onShowGridChange={(show) =>
          setSettings({ ...settings, showGrid: show })
        }
        allowChords={settings.allowChords}
        onAllowChordsChange={(allow) =>
          setSettings({ ...settings, allowChords: allow })
        }
      />

      <HelpModal
        isOpen={ui.showHelp}
        onClose={() => setUI({ ...ui, showHelp: false })}
      />
    </div>
  );
}
